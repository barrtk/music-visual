
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - buffergeometry - lines drawrange</title>
		<meta charset="utf-ax" />
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
		<link type="text/css" rel="stylesheet" href="main.css" />
	</head>
	<body>
		<div id="container"></div>
		<canvas id="music-display"></canvas>
		<div id="player-container" style="display: none;">
			<div id="current-song-title"></div>
			<audio id="audio-player" controls></audio>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "https://unpkg.com/three@0.138.0/build/three.module.js",
					"three/addons/": "https://unpkg.com/three@0.138.0/examples/jsm/"
				}
			}
		</script>

		<script type="module">
			import * as THREE from 'three';

			import Stats from 'three/addons/libs/stats.module.js';

			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
			import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
			import { FontLoader } from 'three/addons/loaders/FontLoader.js';

			let group, spaceship, spaceshipHelper, keys = {};
			let container, stats;
			const particlesData = [];
			let camera, scene, renderer, controls, helper, textMesh, font;
			let positions, colors;
			let particles;
			let pointCloud;
			let particlePositions;
			let linesMesh;

			let textureLoader = new THREE.TextureLoader();
			let baseColorMap, roughnessMap, emissiveMap, metallicMap, normalMap;

			const maxParticleCount = 1000;
			let particleCount = 500;
			const r = 1600;
			const rHalf = r / 2;

			const effectController = {
				showDots: true,
				showLines: true,
				minDistance: 85.55,
				limitConnections: false,
				maxConnections: 20,
				particleCount: 500,
				particleSize: 3,
				particleColor: 0xffffff,
				fillScreen: true,
				showBox: false,
				openFileDialog: function() { document.getElementById('fileInput').click(); },
				nextTrack: function() { playNext(); },
				prevTrack: function() { playPrev(); },
				playPause: function() { 
					if(audioPlayer.paused) {
						audioPlayer.play();
					} else {
						audioPlayer.pause();
					}
				},
				seek: 0,
				bassMultiplier: 0.5,
				midMultiplier: 0.5,
				trebleMultiplier: 0.5,
				cameraMovement: 'orbit',
				cameraSpeed: 0.2,
				randomness: 0.5,
				colorMode: 'static',
				bassColor: 0xff0000,
				midColor: 0x00ff00,
				trebleColor: 0x0000ff,
				text: '',
				trackCamera: false,
				textAsParticles: false,
				textColor: 0xffffff,
				spaceshipSpeed: 1.0,
				spaceshipSize: 0.005,
				spaceshipVisible: true,
				showTestCube: false,
			};

			// Audio
			let audio, analyser, audioPlayer, fileInput;
			let playlist = [];
			let currentTrack = 0;
			let seekSlider;

			init();
			animate();

			function initGUI() {
				const gui = new GUI();

				const musicFolder = gui.addFolder('Music');
				musicFolder.add(effectController, 'openFileDialog').name('Open Files');
				musicFolder.add(effectController, 'prevTrack').name('Previous');
				musicFolder.add(effectController, 'nextTrack').name('Next');
				musicFolder.add(effectController, 'playPause').name('Play/Pause');
				seekSlider = musicFolder.add(effectController, 'seek', 0, 1, 0.01).name('Seek').onChange((value) => {
					if(audioPlayer.duration) {
						audioPlayer.currentTime = value * audioPlayer.duration;
					}
				});

				const visualFolder = gui.addFolder('Visuals');
				visualFolder.add(effectController, 'showDots').onChange(function (value) {
					pointCloud.visible = value;
				});
				visualFolder.add(effectController, 'showLines').onChange(function (value) {
					linesMesh.visible = value;
				});
				visualFolder.add(effectController, 'minDistance', 10, 300);
				visualFolder.add(effectController, 'limitConnections');
				visualFolder.add(effectController, 'maxConnections', 0, 30, 1);
				visualFolder.add(
					effectController,
					'particleCount',
					0,
					maxParticleCount,
					1
				).onChange(function (value) {
					particleCount = parseInt(value);
					particles.setDrawRange(0, particleCount);
				});
				visualFolder.add(effectController, 'particleSize', 1, 10, 1).onChange(function (value) {
					pointCloud.material.size = value;
				});
				visualFolder.add(effectController, 'fillScreen').onChange(function (value) {
					// Re-initialize particles
					initParticles();
				});
				visualFolder.add(effectController, 'showBox').onChange(function (value) {
					helper.visible = value;
				});
				visualFolder.add(effectController, 'bassMultiplier', 0, 2, 0.1);
				visualFolder.add(effectController, 'midMultiplier', 0, 2, 0.1);
				visualFolder.add(effectController, 'trebleMultiplier', 0, 2, 0.1);

				const colorFolder = gui.addFolder('Colors');
				colorFolder.add(effectController, 'colorMode', [ 'static', 'bass', 'mid', 'treble' ] ).name('Color Mode');
				colorFolder.addColor(effectController, 'particleColor').onChange(function (value) {
					pointCloud.material.color.set(value);
				});
				colorFolder.addColor(effectController, 'bassColor');
				colorFolder.addColor(effectController, 'midColor');
				colorFolder.addColor(effectController, 'trebleColor');

				const cameraFolder = gui.addFolder('Advanced Camera');
				cameraFolder.add(effectController, 'cameraMovement', [ 'orbit', 'random', 'still', 'follow', 'flight' ] ).name('Movement');
				cameraFolder.add(effectController, 'cameraSpeed', 0, 5, 0.1).name('Speed');
				cameraFolder.add(effectController, 'randomness', 0, 1, 0.1).name('Randomness');

				const textFolder = gui.addFolder('3D Text');
				textFolder.add(effectController, 'text').name('Text').onChange(createText);
				textFolder.add(effectController, 'trackCamera').name('Track Camera');
				textFolder.add(effectController, 'textAsParticles').name('Text as Particles').onChange(createText);
				textFolder.addColor(effectController, 'textColor').onChange(createText);

				const spaceshipFolder = gui.addFolder('Spaceship');
				spaceshipFolder.add(effectController, 'spaceshipSpeed', 0, 10, 0.1).name('Speed');
				spaceshipFolder.add(effectController, 'spaceshipSize', 0.001, 5, 0.001).name('Size').onChange(function (value) {
					if(spaceship) {
						spaceship.scale.set(value, value, value);
					}
				});
				spaceshipFolder.add(effectController, 'spaceshipVisible').name('Visible').onChange(function (value) {
					if(spaceship) {
						spaceship.visible = value;
					}
				});
				spaceshipFolder.add(effectController, 'showTestCube').name('Show Test Cube').onChange(function (value) {
					if(testCube) {
						testCube.visible = value;
					}
				});
			}

			function init() {
				initGUI();

				container = document.getElementById('container');

				camera = new THREE.PerspectiveCamera(
					45,
					window.innerWidth / window.innerHeight,
					1,
					20000
				);
				camera.position.set(0, 50, 200);

				scene = new THREE.Scene();

				const ambientLight = new THREE.AmbientLight( 0xcccccc, 1.0 ); // Increased intensity
				scene.add( ambientLight );

				const directionalLight = new THREE.DirectionalLight( 0xffffff, 1.5 ); // Increased intensity
				directionalLight.position.set( 1, 1, 1 );
				scene.add( directionalLight );

				const hemisphereLight = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 ); // Added HemisphereLight
				scene.add( hemisphereLight );

				// Test Cube
				const testCube = new THREE.Mesh(new THREE.BoxGeometry(50, 50, 50), new THREE.MeshNormalMaterial());
				testCube.position.set(0, 0, 0);
				testCube.visible = effectController.showTestCube;
				scene.add(testCube);

				group = new THREE.Group();
				scene.add(group);

				helper = new THREE.BoxHelper(
					new THREE.Mesh(new THREE.BoxGeometry(r, r, r))
				);
				helper.material.color.setHex(0x101010);
				helper.material.blending = THREE.AdditiveBlending;
				helper.material.transparent = true;
				group.add(helper);

				const segments = maxParticleCount * maxParticleCount;

				positions = new Float32Array(segments * 3);
				colors = new Float32Array(segments * 3);

				const pMaterial = new THREE.PointsMaterial({
					color: effectController.particleColor,
					size: effectController.particleSize,
					blending: THREE.AdditiveBlending,
					transparent: true,
					sizeAttenuation: false,
				});

				particles = new THREE.BufferGeometry();
				particlePositions = new Float32Array(maxParticleCount * 3);

				initParticles();

				particles.setDrawRange(0, particleCount);
				particles.setAttribute(
					'position',
					new THREE.BufferAttribute(particlePositions, 3).setUsage(
						THREE.DynamicDrawUsage
					)
				);

				pointCloud = new THREE.Points(particles, pMaterial);
				group.add(pointCloud);

				const geometry = new THREE.BufferGeometry();

				geometry.setAttribute(
					'position',
					new THREE.BufferAttribute(positions, 3).setUsage(
						THREE.DynamicDrawUsage
					)
				);
				geometry.setAttribute(
					'color',
					new THREE.BufferAttribute(colors, 3).setUsage(THREE.DynamicDrawUsage)
				);

				geometry.computeBoundingSphere();

				geometry.setDrawRange(0, 0);

				const material = new THREE.LineBasicMaterial({
					vertexColors: true,
					blending: THREE.AdditiveBlending,
					transparent: true,
				});

				linesMesh = new THREE.LineSegments(geometry, material);
				group.add(linesMesh);

				const loader = new FontLoader();
				loader.load( 'https://unpkg.com/three@0.138.0/examples/fonts/helvetiker_regular.typeface.json', function ( f ) {
					font = f;
					createText();
				} );

				baseColorMap = textureLoader.load('models/Tri_Fighter_2_Set_1_BaseColor.png', undefined, undefined, function (err) { console.error('Error loading baseColorMap:', err); });
				roughnessMap = textureLoader.load('models/Tri_Fighter_2_Set_1_Roughness.jpg', undefined, undefined, function (err) { console.error('Error loading roughnessMap:', err); });
				emissiveMap = textureLoader.load('models/Tri_Fighter_2_Set_1_Emissive.jpg', undefined, undefined, function (err) { console.error('Error loading emissiveMap:', err); });
				metallicMap = textureLoader.load('models/Tri_Fighter_2_Set_1_Metallic.jpg', undefined, undefined, function (err) { console.error('Error loading metallicMap:', err); });
				normalMap = textureLoader.load('models/Tri_Fighter_2_Set_1_Normal.jpg', undefined, undefined, function (err) { console.error('Error loading normalMap:', err); }); // Assuming this filename

				const spaceshipMaterial = new THREE.MeshStandardMaterial({
					map: baseColorMap,
					roughnessMap: roughnessMap,
					emissiveMap: emissiveMap,
					metalnessMap: metallicMap,
					normalMap: normalMap,
				});

				const fbxLoader = new FBXLoader();
				fbxLoader.load('models/statek1.fbx', function (object) {
					spaceship = object;
					spaceship.scale.set(effectController.spaceshipSize, effectController.spaceshipSize, effectController.spaceshipSize);
					spaceship.position.set(0, 0, 0);
					spaceship.visible = effectController.spaceshipVisible;
					scene.add(spaceship);

					spaceship.traverse(function (child) {
						if (child.isMesh) {
							child.material = spaceshipMaterial;
						}
					});

					spaceshipHelper = new THREE.BoxHelper(spaceship, 0xffff00);
					scene.add(spaceshipHelper);
					console.log('Spaceship loaded:', spaceship);
				});

				renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.outputEncoding = THREE.sRGBEncoding;

				container.appendChild(renderer.domElement);

				controls = new OrbitControls( camera, renderer.domElement );
				controls.update();

				stats = new Stats();
				container.appendChild(stats.dom);

				window.addEventListener('keydown', function(event) {
					keys[event.code] = true;
				});
				window.addEventListener('keyup', function(event) {
					keys[event.code] = false;
				});

				window.addEventListener('resize', onWindowResize);

				// Audio
				audioPlayer = document.getElementById('audio-player');

				fileInput = document.createElement('input');
				fileInput.type = 'file';
				fileInput.id = 'fileInput';
				fileInput.accept = 'audio/*';
				fileInput.multiple = true;
				fileInput.style.display = 'none';
				document.body.appendChild(fileInput);

				fileInput.addEventListener('change', (event) => {
					playlist = Array.from(event.target.files);
					currentTrack = 0;
					playTrack(currentTrack);
				});

				audioPlayer.addEventListener('ended', () => {
					playNext();
				});

				audioPlayer.addEventListener('timeupdate', () => {
					if(audioPlayer.duration) {
						effectController.seek = audioPlayer.currentTime / audioPlayer.duration;
						seekSlider.updateDisplay();
					}
				});

			}

			function createText() {
				if(!font) return;
				if(textMesh) {
					scene.remove(textMesh);
				}
				const textGeo = new TextGeometry( effectController.text, {
					font: font,
					size: 50,
					height: 5,
					curveSegments: 12,
					bevelEnabled: true,
					bevelThickness: 2,
					bevelSize: 1,
					bevelOffset: 0,
					bevelSegments: 5
				} );
				textGeo.center();

				if(effectController.textAsParticles) {
					const vertices = textGeo.attributes.position.array;
					for(let i = 0; i < vertices.length; i+=3) {
						if(particleCount < maxParticleCount) {
							particlePositions[particleCount * 3] = vertices[i];
							particlePositions[particleCount * 3 + 1] = vertices[i+1];
							particlePositions[particleCount * 3 + 2] = vertices[i+2];
							particlesData[particleCount] = {
								velocity: new THREE.Vector3(
									-1 + Math.random() * 2,
									-1 + Math.random() * 2,
									-1 + Math.random() * 2
								),
								numConnections: 0,
							};
							particleCount++;
						}
					}
					particles.setDrawRange(0, particleCount);
					pointCloud.geometry.attributes.position.needsUpdate = true;
				} else {
					const textMaterial = new THREE.MeshPhongMaterial( { color: effectController.textColor, flatShading: true } );
					textMesh = new THREE.Mesh( textGeo, textMaterial );
					scene.add( textMesh );
				}
			}

			function playTrack(trackIndex) {
				if (trackIndex >= 0 && trackIndex < playlist.length) {
					const file = playlist[trackIndex];
					const url = URL.createObjectURL(file);
					audioPlayer.src = url;
					audioPlayer.play();
					document.getElementById('current-song-title').textContent = `Now playing: ${file.name}`;
					currentTrack = trackIndex;

					const listener = new THREE.AudioListener();
					camera.add(listener);

					audio = new THREE.Audio(listener);
					audio.setMediaElementSource(audioPlayer);

					analyser = new THREE.AudioAnalyser(audio, 256);
				}
			}

			function playNext() {
				let nextTrack = currentTrack + 1;
				if (nextTrack >= playlist.length) {
					nextTrack = 0;
				}
				playTrack(nextTrack);
			}

			function playPrev() {
				let prevTrack = currentTrack - 1;
				if (prevTrack < 0) {
					prevTrack = playlist.length - 1;
				}
				playTrack(prevTrack);
			}

			function initParticles() {
				particlesData.length = 0;
				for (let i = 0; i < maxParticleCount; i++) {
					let x, y, z;
					if (effectController.fillScreen) {
						x = Math.random() * window.innerWidth - window.innerWidth / 2;
						y = Math.random() * window.innerHeight - window.innerHeight / 2;
						z = Math.random() * r - r / 2;
					} else {
						x = Math.random() * r - r / 2;
						y = Math.random() * r - r / 2;
						z = Math.random() * r - r / 2;
					}


					particlePositions[i * 3] = x;
					particlePositions[i * 3 + 1] = y;
					particlePositions[i * 3 + 2] = z;

					particlesData.push({
						velocity: new THREE.Vector3(
							-1 + Math.random() * 2,
							-1 + Math.random() * 2,
							-1 + Math.random() * 2
						),
						numConnections: 0,
					});
				}
				if(pointCloud) pointCloud.geometry.attributes.position.needsUpdate = true;

			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			function updateSpaceshipControls() {
				if(!spaceship) return;

				const speed = effectController.spaceshipSpeed;
				const rotationSpeed = 0.02;

				if (effectController.cameraMovement === 'flight') {
					if(keys['KeyW']) {
						spaceship.translateZ(-speed);
					}
					if(keys['KeyS']) {
						spaceship.translateZ(speed);
					}
					if(keys['KeyA']) {
						spaceship.rotateY(rotationSpeed);
					}
					if(keys['KeyD']) {
						spaceship.rotateY(-rotationSpeed);
					}
					if(keys['ArrowUp']) {
						spaceship.rotateX(rotationSpeed);
					}
					if(keys['ArrowDown']) {
						spaceship.rotateX(-rotationSpeed);
					}
					if(keys['ArrowLeft']) {
						spaceship.rotateZ(rotationSpeed);
					}
					if(keys['ArrowRight']) {
						spaceship.rotateZ(-rotationSpeed);
					}
				} else {
					if(keys['KeyW']) {
						spaceship.translateZ(speed);
					}
					if(keys['KeyS']) {
						spaceship.translateZ(-speed);
					}
					if(keys['KeyA']) {
						spaceship.rotateY(rotationSpeed);
					}
					if(keys['KeyD']) {
						spaceship.rotateY(-rotationSpeed);
					}
					if(keys['ArrowUp']) {
						spaceship.rotateX(rotationSpeed);
					}
					if(keys['ArrowDown']) {
						spaceship.rotateX(-rotationSpeed);
					}
					if(keys['ArrowLeft']) {
						spaceship.rotateZ(rotationSpeed);
					}
					if(keys['ArrowRight']) {
						spaceship.rotateZ(-rotationSpeed);
					}
				}
			}

			function animate() {
				updateSpaceshipControls();

				let vertexpos = 0;
				let colorpos = 0;
				let numConnected = 0;

				switch(effectController.cameraMovement) {
					case 'orbit':
						controls.autoRotate = true;
						controls.autoRotateSpeed = effectController.cameraSpeed;
						break;
					case 'random':
						controls.autoRotate = false;
						const time = Date.now() * 0.0001;
						camera.position.x += Math.sin(time * effectController.cameraSpeed) * effectController.randomness * 10;
						camera.position.y += Math.cos(time * effectController.cameraSpeed) * effectController.randomness * 10;
						camera.position.z += Math.cos(time * effectController.cameraSpeed) * effectController.randomness * 10;
						if(textMesh) {
							const distance = camera.position.distanceTo(textMesh.position);
							if(distance > 1000) {
									camera.position.lerp(textMesh.position, 0.1);
							}
							camera.lookAt(textMesh.position);
						}
						break;
					case 'still':
						controls.autoRotate = false;
						controls.enabled = true;
						break;
					case 'follow':
						controls.autoRotate = false;
						if(spaceship) {
							const offset = new THREE.Vector3(0, 20, -50);
							offset.applyQuaternion(spaceship.quaternion);
							camera.position.copy(spaceship.position).add(offset);
							camera.lookAt(spaceship.position);
						}
						break;
					case 'flight':
						controls.enabled = false;
						if(spaceship) {
							const cameraOffset = new THREE.Vector3(0, 10, -20); // Adjusted for above and behind
							camera.position.copy(spaceship.position).add(cameraOffset.applyQuaternion(spaceship.quaternion));
							camera.quaternion.copy(spaceship.quaternion);
						}
						break;
				}

				if (controls.enabled) {
					controls.update();
				}

				if(spaceshipHelper) {
					spaceshipHelper.update();
				}

				for (let i = 0; i < particleCount; i++){
					if(particlesData[i]) particlesData[i].numConnections = 0;
				}
				if (analyser) {
					const data = analyser.getFrequencyData();

					const bass = data.slice(0, 10).reduce((a, b) => a + b, 0) / 10;
					const mid = data.slice(10, 20).reduce((a, b) => a + b, 0) / 10;
					const treble = data.slice(20, 30).reduce((a, b) => a + b, 0) / 10;

					const guiMinDistance = effectController.minDistance;
					effectController.minDistance = bass > guiMinDistance ? bass : guiMinDistance;

					for (let i = 0; i < particleCount; i++) {
						if(particlesData[i]){
							const particleData = particlesData[i];
							particleData.velocity.x = (Math.random() - 0.5) * bass * effectController.bassMultiplier;
							particleData.velocity.y = (Math.random() - 0.5) * mid * effectController.midMultiplier;
							particleData.velocity.z = (Math.random() - 0.5) * treble * effectController.trebleMultiplier;
						}
					}

					switch(effectController.colorMode) {
						case 'static':
							pointCloud.material.color.set(effectController.particleColor);
							break;
						case 'bass':
							pointCloud.material.color.set(new THREE.Color(bass/255, 0, 0));
							break;
						case 'mid':
							pointCloud.material.color.set(new THREE.Color(0, mid/255, 0));
							break;
						case 'treble':
							pointCloud.material.color.set(new THREE.Color(0, 0, treble/255));
							break;
					}
				}

				if(effectController.trackCamera && textMesh) {
					textMesh.position.copy(camera.position);
					textMesh.rotation.copy(camera.rotation);
					textMesh.translateZ(-200);
				}

				for (let i = 0; i < particleCount; i++) {
					if(particlesData[i]){
						const particleData = particlesData[i];

						particlePositions[i * 3] += particleData.velocity.x;
						particlePositions[i * 3 + 1] += particleData.velocity.y;
						particlePositions[i * 3 + 2] += particleData.velocity.z;

						if (
							particlePositions[i * 3 + 1] < -rHalf ||
							particlePositions[i * 3 + 1] > rHalf
						)
							particleData.velocity.y = -particleData.velocity.y;

						if (
							particlePositions[i * 3] < -rHalf ||
							particlePositions[i * 3] > rHalf
						)
							particleData.velocity.x = -particleData.velocity.x;

						if (
							particlePositions[i * 3 + 2] < -rHalf ||
							particlePositions[i * 3 + 2] > rHalf
						)
							particleData.velocity.z = -particleData.velocity.z;

						if (
							effectController.limitConnections &&
							particleData.numConnections >= effectController.maxConnections
						)
							continue;

						for (let j = i + 1; j < particleCount; j++) {
							if(particlesData[j]){
								const particleDataB = particlesData[j];
								if (
									effectController.limitConnections &&
									particleDataB.numConnections >= effectController.maxConnections
								)
									continue;

								const dx = particlePositions[i * 3] - particlePositions[j * 3];
								const dy =
									particlePositions[i * 3 + 1] - particlePositions[j * 3 + 1];
								const dz =
									particlePositions[i * 3 + 2] - particlePositions[j * 3 + 2];
								const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

								if (dist < effectController.minDistance) {
									particleData.numConnections++;
									particleDataB.numConnections++;

									const alpha = 1.0 - dist / effectController.minDistance;

									positions[vertexpos++] = particlePositions[i * 3];
									positions[vertexpos++] = particlePositions[i * 3 + 1];
									positions[vertexpos++] = particlePositions[i * 3 + 2];

									positions[vertexpos++] = particlePositions[j * 3];
									positions[vertexpos++] = particlePositions[j * 3 + 1];
									positions[vertexpos++] = particlePositions[j * 3 + 2];

									colors[colorpos++] = alpha;
									colors[colorpos++] = alpha;
									colors[colorpos++] = alpha;

									colors[colorpos++] = alpha;
									colors[colorpos++] = alpha;
									colors[colorpos++] = alpha;

									numConnected++;
								}
							}
						}
					}
				}

				linesMesh.geometry.setDrawRange(0, numConnected * 2);
				linesMesh.geometry.attributes.position.needsUpdate = true;
				linesMesh.geometry.attributes.color.needsUpdate = true;

				pointCloud.geometry.attributes.position.needsUpdate = true;

				requestAnimationFrame(animate);

				stats.update();
				render();
			}

			function render() {

				if (analyser) {
					const data = analyser.getFrequencyData();
					const canvas = document.getElementById('music-display');
					const context = canvas.getContext('2d');
					canvas.width = data.length;
					canvas.height = 100;
					context.clearRect(0, 0, canvas.width, canvas.height);
					context.fillStyle = 'white';

					for (let i = 0; i < data.length; i++) {
						const barHeight = data[i];
						context.fillRect(i, canvas.height - barHeight, 1, barHeight);
					}
				}

				renderer.render(scene, camera);
			}
		</script>
	</body>
</html>
